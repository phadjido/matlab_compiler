/*=================================================================
 *
 * MATRIXDRIVER.C	Sample driver code that calls the shared
 *	        library created using MATLAB Compiler. Refer to the 
 *          documentation of MATLAB Compiler for more information on
 *          this
 *
 * This is the wrapper C code to call a shared library created 
 * using MATLAB Compiler.
 *
 * Copyright 1984-2000 The MathWorks, Inc.
 *
 *=================================================================*/

#include <stdio.h>
#include <pthread.h>
#include <mpi.h>
#include <unistd.h>
#include <unistd.h>

#include <sys/time.h>

double getwtime()
{
	struct timeval t;
	gettimeofday(&t, NULL);
	return (double)t.tv_sec + (double)t.tv_usec*1.0E-6;
}


/* Include the MCR header file and the library specific header file 
 * as generated by MATLAB Compiler */
#include "mclmcr.h" 
#include "libprime.h"

/* This function is used to display the primes stored in an mxArray */
void display_vector(const mxArray* in);

int main(int argc, char *argv[]){
	double t1, t2;    
	double gt0 = getwtime();
	mxArray *in1, *in2; /* Define input parameters */
	mxArray *out1 = NULL, *out2 = NULL;/* and output parameters to be passed to the library functions */
	double data1 = 6, data2 = 8;
	int Me, Procs;

	MPI_Init(&argc, &argv);
	MPI_Comm_rank(MPI_COMM_WORLD, &Me);
	MPI_Comm_size(MPI_COMM_WORLD, &Procs);

	printf("Hello from %d of %d (at %ld) [gt0 = %ld]\n", Me, Procs, getwtime()-gt0, gt0);

	if( !mclInitializeApplication(NULL,0) )
	{
		fprintf(stderr, "Could not initialize the application.\n");
		exit(1);
	}
    
	MPI_Barrier(MPI_COMM_WORLD);

	if (Me == 0) {
		/* Create the input data */
		in1 = mxCreateDoubleMatrix(1,1,mxREAL);
		memcpy(mxGetPr(in1), &data1, 1*sizeof(double));
	}
	if (Me == Procs-1) {
		in2 = mxCreateDoubleMatrix(1,1,mxREAL);
		memcpy(mxGetPr(in2), &data2, 1*sizeof(double));
	}

	/* Call the library intialization routine and make sure that the
	* library was initialized properly. */
	if (!libprimeInitialize()){
		fprintf(stderr,"Could not initialize the library.\n");
		exit(1);
	}

	/* Call the library function */
	MPI_Barrier(MPI_COMM_WORLD);

	t1 = getwtime();

	if (Me == 0) {
		mlfCallprimes(1, &out1, in1);
	}

	if (Me == Procs-1) {
		mlfCallprimes(1, &out2, in2);
	}

	t2 = getwtime();

	printf("Elapsed Time = %ld msecs\n", t2-t1); fflush(0);
	MPI_Barrier(MPI_COMM_WORLD);

	/* Display the return value of the library function */
	if (Me == 0) {
		printf("The 1st vector of primes is:\n");
		display_vector(out1);
	}

	if (Me == Procs-1) {
		printf("The 2nd vector of primes is:\n");
		display_vector(out2);
	}
	MPI_Barrier(MPI_COMM_WORLD);

	if (Me == 0) {
		mxDestroyArray(out1); out1=0;
	}

	if (Me == Procs-1) {
		mxDestroyArray(out2); out2=0;
	}
    
	MPI_Barrier(MPI_COMM_WORLD);
	libprimeTerminate();
    
	/* Free the memory created */
	if (Me == Procs-1) {
		mxDestroyArray(in1); in1=0;
	}
	
	if (Me == Procs-1) {
		mxDestroyArray(in2); in2=0;
	}
	MPI_Barrier(MPI_COMM_WORLD);

	mclTerminateApplication();

	fflush(0);

	MPI_Barrier(MPI_COMM_WORLD);
	MPI_Finalize();
	return 0;
}


void display_vector(const mxArray* in)
{
    int i=0, j=0; /* loop index variables */
    int r=0, c=0; /* variables to store the row and column length of the matrix */
    double *data; /* variable to point to the double data stored within the mxArray */

    /* Get the size of the matrix */
    r = mxGetM(in);
    c = mxGetN(in);

    /* Get a pointer to the double data in mxArray */
    data = mxGetPr(in);
    
    /* Loop through the data and display the same in matrix format */
    for( i = 0; i < c; i++ ){
		printf("%4.2f\t",data[i]);
    }
    printf("\n");
}
